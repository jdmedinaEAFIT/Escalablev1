# Ejercicios Prácticos y Laboratorios
## MercadoRápido - Actividades para Estudiantes

---

## EJERCICIO 1: ANÁLISIS DE LIMITACIONES DEL MONOLITO

### Objetivo
Identificar y documentar los límites y problemas del sistema monolítico actual.

### Contexto
Tienes acceso a los logs del Black Friday 2024 (el desastre) y al código del monolito.

### Actividad

#### Parte A: Análisis de Logs (30 minutos)

Analiza los siguientes logs simulados:

```
[2024-11-29 09:15:23] INFO  OrderController - Creating order for user: user_12345
[2024-11-29 09:15:23] INFO  InventoryService - Checking stock for 3 items
[2024-11-29 09:15:24] WARN  Database - Connection pool 450/500 (90% utilization)
[2024-11-29 09:15:26] ERROR PaymentService - Timeout calling payment gateway (5000ms)
[2024-11-29 09:15:26] ERROR OrderController - Failed to create order: PaymentTimeoutException
[2024-11-29 09:15:26] INFO  InventoryService - Rolling back stock for order

[2024-11-29 09:30:45] ERROR Database - Connection pool exhausted (500/500)
[2024-11-29 09:30:45] ERROR OrderController - Cannot acquire database connection
[2024-11-29 09:30:45] ERROR CatalogController - Cannot acquire database connection
[2024-11-29 09:30:45] ERROR SearchController - Cannot acquire database connection

[2024-11-29 09:45:12] CRITICAL System - CPU utilization: 98%
[2024-11-29 09:45:12] CRITICAL System - Memory utilization: 95%
[2024-11-29 09:45:13] CRITICAL LoadBalancer - All instances unhealthy
[2024-11-29 09:45:13] CRITICAL LoadBalancer - Returning 503 to all requests
```

**Preguntas:**

1. ¿Cuál fue la secuencia de fallos que llevó al colapso total?
2. ¿Qué componente inició la cascada de fallos?
3. ¿Qué patrón de resiliencia habría evitado esto?
4. ¿Cómo afectó el fallo de un módulo a los demás?

**Entregable:** Diagrama de causa-efecto y propuestas de solución.

---

#### Parte B: Identificación de Anti-Patrones (30 minutos)

Revisa este fragmento de código y encuentra todos los anti-patrones:

```java
@PostMapping("/checkout")
public Order checkout(@RequestBody CheckoutRequest request) {
    // 1. Validar carrito
    Cart cart = cartService.getCart(request.getUserId());
    
    // 2. Verificar stock (N+1 queries)
    for (CartItem item : cart.getItems()) {
        Product p = productRepository.findById(item.getProductId()).get();
        if (p.getStock() < item.getQuantity()) {
            throw new RuntimeException("Sin stock");
        }
        p.setStock(p.getStock() - item.getQuantity());
        productRepository.save(p);
    }
    
    // 3. Crear orden
    Order order = new Order();
    order.setItems(cart.getItems());
    order = orderRepository.save(order);
    
    // 4. Procesar pago (sin timeout, sin retry)
    PaymentResult payment = paymentGateway.charge(order.getTotal());
    if (!payment.isSuccess()) {
        throw new RuntimeException("Pago falló");
    }
    
    // 5. Enviar email (bloqueante)
    emailService.send(order.getUserEmail(), "Confirmación", buildEmail(order));
    
    // 6. Actualizar analytics (bloqueante)
    analyticsService.track("ORDER_PLACED", order);
    
    // 7. Generar factura (proceso pesado, bloqueante)
    Invoice invoice = invoiceGenerator.generate(order); // 5 segundos
    
    return order;
}
```

**Encuentra y documenta:**
1. ❌ Problemas de performance
2. ❌ Falta de resiliencia
3. ❌ Acoplamiento excesivo
4. ❌ Manejo de errores inadecuado
5. ❌ Operaciones bloqueantes innecesarias

**Entregable:** Lista de problemas con severidad (crítico/alto/medio/bajo) y propuestas de refactoring.

---

## EJERCICIO 2: DISEÑO DE CIRCUIT BREAKER

### Objetivo
Implementar el patrón Circuit Breaker para proteger el sistema de fallos en cascada.

### Contexto
El servicio de pagos es externo y frecuentemente experimenta latencia alta o timeouts.

### Actividad

#### Parte A: Configuración del Circuit Breaker (45 minutos)

Completa la siguiente configuración de Resilience4j:

```yaml
resilience4j:
  circuitbreaker:
    instances:
      paymentService:
        slidingWindowSize: ??      # ¿Cuántos requests monitorear?
        failureRateThreshold: ??   # ¿Qué % de errores para abrir?
        waitDurationInOpenState: ?? # ¿Cuánto esperar antes de intentar?
        permittedNumberOfCallsInHalfOpenState: ??
        slowCallRateThreshold: ??
        slowCallDurationThreshold: ??
```

**Preguntas a resolver:**

1. Si procesamos 1000 pagos/minuto, ¿qué `slidingWindowSize` usarías?
2. ¿Qué `failureRateThreshold` es apropiado para un servicio crítico?
3. Durante Black Friday, ¿usarías valores más o menos conservadores?
4. ¿Cómo balanceas entre protección y disponibilidad?

**Casos a simular:**

| Escenario | Tasa Error | Latencia | ¿Circuit abre? | Razón |
|-----------|-----------|----------|----------------|-------|
| 1. Normal | 2% | 100ms | ? | ? |
| 2. Pico | 15% | 500ms | ? | ? |
| 3. Degradado | 45% | 2000ms | ? | ? |
| 4. Caída | 80% | timeout | ? | ? |

---

#### Parte B: Implementación de Fallback (45 minutos)

Implementa un método fallback para cuando el circuit breaker se active:

```java
@Service
public class PaymentService {
    
    @CircuitBreaker(name = "paymentService", fallbackMethod = "processPendingPayment")
    public PaymentResult processPayment(Order order) {
        // Llamada al gateway externo
        return paymentGateway.charge(order.getTotal());
    }
    
    // TODO: Implementar fallback
    private PaymentResult processPendingPayment(Order order, Exception e) {
        // ¿Qué hacer cuando el servicio de pagos no está disponible?
        // Opciones:
        // 1. Rechazar la orden
        // 2. Marcar como "pago pendiente"
        // 3. Encolar para procesamiento posterior
        // 4. Ofrecer método alternativo
        
        // TU IMPLEMENTACIÓN AQUÍ
    }
}
```

**Criterios de evaluación:**
- ✅ No perder la venta
- ✅ Experiencia de usuario aceptable
- ✅ Garantías de consistencia
- ✅ Proceso de reconciliación

**Entregable:** 
1. Código del fallback implementado
2. Flujo de reconciliación cuando el servicio se recupera
3. Notificaciones al usuario

---

## EJERCICIO 3: DESCOMPOSICIÓN EN MICROSERVICIOS

### Objetivo
Diseñar la estrategia de descomposición del monolito siguiendo Domain-Driven Design.

### Actividad

#### Parte A: Identificación de Bounded Contexts (60 minutos)

El monolito actual tiene estos módulos:

```
MercadoRápido Monolito:
├── Catalog (productos, categorías, búsqueda)
├── Inventory (stock, almacenes, reservas)
├── Orders (órdenes, items, estados)
├── Payments (transacciones, métodos de pago)
├── Users (perfiles, autenticación, preferencias)
├── Cart (carrito de compras, sesiones)
├── Shipping (envíos, tracking, carriers)
├── Notifications (emails, SMS, push)
├── Reviews (calificaciones, comentarios)
├── Analytics (reportes, métricas, dashboards)
├── Promotions (descuentos, cupones, ofertas)
└── Recommendations (ML, sugerencias)
```

**Tareas:**

1. **Agrupa en Bounded Contexts lógicos**
   - ¿Qué módulos tienen alta cohesión?
   - ¿Dónde están los límites transaccionales naturales?
   - ¿Qué módulos comparten el mismo lenguaje de negocio?

2. **Define las fronteras de los microservicios**
   - ¿Cuántos microservicios propones? (Recomendación: 5-8)
   - ¿Qué responsabilidad tiene cada uno?
   - ¿Cómo se comunican entre sí?

3. **Ejemplo de solución propuesta:**

```
Propuesta de Microservicios:

1. Catalog Service
   - Productos
   - Categorías  
   - Búsqueda
   - BD: PostgreSQL + Elasticsearch

2. Order Management Service
   - Órdenes
   - Items
   - Estados
   - BD: MongoDB

3. Inventory Service
   - Stock
   - Reservas
   - Almacenes
   - BD: PostgreSQL

4. Payment Service
   - Transacciones
   - Métodos de pago
   - BD: PostgreSQL

5. User Service
   - Perfiles
   - Autenticación
   - Preferencias
   - BD: PostgreSQL

6. Notification Service
   - Emails
   - SMS
   - Push
   - BD: None (stateless)

7. ... (completa tu propuesta)
```

**Criterios:**
- Evitar microservicios "nano" (demasiado pequeños)
- Minimizar dependencias entre servicios
- Agrupar datos que cambian juntos
- Considerar diferentes patrones de escalamiento

---

#### Parte B: Diseño de Comunicación (60 minutos)

Para tu propuesta de microservicios, diseña:

**1. Flujo de creación de orden (síncrono vs asíncrono)**

```
Usuario hace checkout
    ↓
¿Qué servicios se invocan?
¿Cuáles son síncronos (HTTP)?
¿Cuáles son asíncronos (eventos)?
    ↓
Diseña el flujo completo
```

**Ejemplo de solución:**

```
FLUJO SÍNCRONO (crítico para respuesta):
1. API Gateway recibe POST /checkout
2. Order Service ← (HTTP) → Inventory Service (verificar stock)
3. Order Service crea orden en BD (estado: PENDING)
4. Order Service devuelve respuesta al usuario

FLUJO ASÍNCRONO (post-procesamiento):
5. Order Service publica evento "OrderCreated"
6. Payment Service consume evento → procesa pago
7. Payment Service publica evento "PaymentProcessed"
8. Order Service consume → actualiza estado orden
9. Notification Service consume → envía email
10. Inventory Service consume → confirma reserva
```

**Documenta:**
- ¿Por qué elegiste síncrono vs asíncrono para cada interacción?
- ¿Qué pasa si un servicio falla?
- ¿Cómo mantienes consistencia?

**2. Definición de eventos**

Diseña el schema de eventos para:

```json
{
  "eventType": "order.created",
  "eventId": "???",
  "timestamp": "???",
  "payload": {
    // ¿Qué información incluyes?
    // ¿Incluyes toda la orden o solo referencia?
  }
}
```

**Eventos requeridos:**
- order.created
- order.payment.processed
- order.payment.failed
- order.shipped
- inventory.reserved
- inventory.released

---

## EJERCICIO 4: IMPLEMENTACIÓN DE SAGA PATTERN

### Objetivo
Manejar transacciones distribuidas usando el patrón Saga.

### Contexto
El proceso de checkout involucra múltiples servicios y debe ser atómico.

### Actividad (90 minutos)

#### Escenario: Checkout Distribuido

**Servicios involucrados:**
1. Order Service
2. Inventory Service
3. Payment Service
4. Loyalty Service (puntos de fidelidad)

**Happy Path:**
```
1. Crear orden (Order Service)
2. Reservar inventario (Inventory Service)
3. Procesar pago (Payment Service)
4. Acreditar puntos (Loyalty Service)
✅ Checkout exitoso
```

**Fallo en paso 3 (pago rechazado):**
```
1. Crear orden ✅
2. Reservar inventario ✅
3. Procesar pago ❌
4. COMPENSACIÓN: Liberar inventario
5. COMPENSACIÓN: Cancelar orden
```

**Tarea:**

Implementa la Saga usando coreografía (eventos):

```java
// OrderService.java
@Service
public class OrderService {
    
    @Transactional
    public Order createOrder(OrderRequest request) {
        // 1. Guardar orden en estado PENDING
        Order order = saveOrder(request);
        
        // 2. Publicar evento
        eventPublisher.publish(new OrderCreatedEvent(order));
        
        return order;
    }
    
    @EventListener
    public void handleInventoryReserved(InventoryReservedEvent event) {
        // TODO: ¿Qué hacer cuando inventario se reserva?
    }
    
    @EventListener
    public void handlePaymentFailed(PaymentFailedEvent event) {
        // TODO: Implementar compensación
        // ¿Cómo liberar inventario?
        // ¿Cómo notificar al usuario?
    }
}

// InventoryService.java
@Service
public class InventoryService {
    
    @EventListener
    public void handleOrderCreated(OrderCreatedEvent event) {
        try {
            // TODO: Reservar stock
            // Si éxito → publicar InventoryReservedEvent
            // Si fallo → publicar InventoryReservationFailedEvent
        } catch (InsufficientStockException e) {
            // TODO: ¿Qué evento publicar?
        }
    }
    
    @EventListener
    public void handlePaymentFailed(PaymentFailedEvent event) {
        // TODO: Compensación - liberar stock
    }
}

// PaymentService.java
@Service
public class PaymentService {
    
    @EventListener
    public void handleInventoryReserved(InventoryReservedEvent event) {
        try {
            // TODO: Procesar pago
            // Si éxito → publicar PaymentSuccessEvent
            // Si fallo → publicar PaymentFailedEvent
        } catch (PaymentException e) {
            // TODO: Manejar fallo
        }
    }
}
```

**Matriz de compensación a diseñar:**

| Paso | Acción | Compensación | Quien compensa |
|------|--------|--------------|----------------|
| 1 | Crear orden | Cancelar orden | Order Service |
| 2 | Reservar inventario | Liberar inventario | Inventory Service |
| 3 | Procesar pago | Reembolsar pago | Payment Service |
| 4 | Acreditar puntos | Debitar puntos | Loyalty Service |

**Preguntas críticas:**
1. ¿Qué pasa si la compensación falla?
2. ¿Cómo garantizas que cada evento se procesa exactamente una vez?
3. ¿Cómo manejas timeouts en cada paso?
4. ¿Cómo monitorizas el estado de la saga?

---

## EJERCICIO 5: CONFIGURACIÓN DE AUTO-SCALING

### Objetivo
Configurar auto-scaling basado en métricas para manejar picos de tráfico.

### Contexto
Black Friday genera 15x el tráfico normal. Necesitas que el sistema escale automáticamente.

### Actividad (60 minutos)

#### Parte A: Análisis de Métricas

Tienes estos datos históricos de Black Friday:

```
Hora   | Requests/s | CPU (%) | Memoria (%) | Latencia P95 (ms)
-------|-----------|---------|-------------|------------------
08:00  | 1,000     | 40%     | 50%         | 200
09:00  | 15,000    | 85%     | 75%         | 1,500
10:00  | 22,000    | 95%     | 90%         | 3,000
11:00  | 18,000    | 90%     | 85%         | 2,200
12:00  | 12,000    | 70%     | 70%         | 800
```

**Preguntas:**

1. ¿En qué métrica deberías basar el auto-scaling?
   - [ ] CPU
   - [ ] Memoria
   - [ ] Requests/segundo
   - [ ] Latencia
   - [ ] Combinación (¿cuál?)

2. ¿Cuál debería ser el threshold para escalar?
   - Si eliges CPU: ____%
   - Si eliges requests/s: ____ req/s por pod

3. ¿Cuántos pods mínimos y máximos?
   - Min replicas: ____
   - Max replicas: ____

---

#### Parte B: Configuración HPA

Completa esta configuración de Kubernetes HPA:

```yaml
apiVersion: autoscaling/v2
kind: HorizontalPodAutoscaler
metadata:
  name: catalog-service-hpa
spec:
  scaleTargetRef:
    apiVersion: apps/v1
    kind: Deployment
    name: catalog-service
  minReplicas: ???  # TU RESPUESTA
  maxReplicas: ???  # TU RESPUESTA
  metrics:
  - type: Resource
    resource:
      name: cpu
      target:
        type: Utilization
        averageUtilization: ???  # TU RESPUESTA
  - type: Resource
    resource:
      name: memory
      target:
        type: Utilization
        averageUtilization: ???  # TU RESPUESTA
  - type: Pods
    pods:
      metric:
        name: http_requests_per_second
      target:
        type: AverageValue
        averageValue: "???"  # TU RESPUESTA
  behavior:
    scaleUp:
      stabilizationWindowSeconds: ???  # ¿Qué tan rápido escalar?
      policies:
      - type: Percent
        value: ???  # ¿Cuánto escalar cada vez?
        periodSeconds: ???
    scaleDown:
      stabilizationWindowSeconds: ???  # ¿Esperar antes de reducir?
      policies:
      - type: Percent
        value: ???
        periodSeconds: ???
```

**Justifica tus decisiones:**
- ¿Por qué elegiste esos valores min/max?
- ¿Por qué ese threshold de CPU?
- ¿Por qué esa velocidad de scale-up vs scale-down?

---

#### Parte C: Simulación de Carga

Diseña un plan de pruebas de carga:

**Escenarios a probar:**

1. **Carga Normal → Pico Súbito**
   - 1,000 req/s → 10,000 req/s en 1 minuto
   - ¿Cuánto tarda en escalar?
   - ¿Cuál es la latencia durante el escalamiento?

2. **Pico → Normalización**
   - 10,000 req/s → 1,000 req/s
   - ¿Cuándo empieza a reducir pods?
   - ¿Evita "flapping" (escalar arriba/abajo constantemente)?

3. **Tráfico Sostenido**
   - 5,000 req/s constante por 2 horas
   - ¿Cuántos pods mantiene?
   - ¿Es eficiente en costos?

**Herramientas sugeridas:**
- Apache JMeter
- k6
- Locust

```python
# Ejemplo con Locust
from locust import HttpUser, task, between

class CatalogUser(HttpUser):
    wait_time = between(1, 2)
    
    @task(3)  # 3x más frecuente
    def search_products(self):
        self.client.get("/api/products/search?q=laptop")
    
    @task(1)
    def get_product(self):
        product_id = random.randint(1, 10000)
        self.client.get(f"/api/products/{product_id}")
```

---

## EJERCICIO 6: OBSERVABILIDAD Y MONITOREO

### Objetivo
Implementar observabilidad completa siguiendo los tres pilares: métricas, logs, traces.

### Actividad (90 minutos)

#### Parte A: Métricas Custom

Implementa métricas de negocio para el Order Service:

```java
@Component
public class OrderBusinessMetrics {
    
    private final MeterRegistry registry;
    
    // TODO: Implementar las siguientes métricas
    
    // 1. Counter: Total de órdenes por estado
    // orders.total{status=PENDING|PAID|SHIPPED|CANCELLED}
    
    // 2. Gauge: Valor promedio de órdenes últimas 24h
    // orders.average_value
    
    // 3. Timer: Tiempo desde creación hasta pago
    // orders.time_to_payment
    
    // 4. Distribution Summary: Distribución de valores de órdenes
    // orders.value.distribution
    
    public void recordOrderCreated(Order order) {
        // TU IMPLEMENTACIÓN
    }
    
    public void recordOrderPaid(Order order, Duration timeToPay) {
        // TU IMPLEMENTACIÓN
    }
}
```

**Preguntas:**
1. ¿Qué percentiles son importantes para el negocio?
2. ¿Qué alertas configurarías basadas en estas métricas?

---

#### Parte B: Distributed Tracing

Diseña los spans para el flujo de checkout:

```
Trace: checkout_flow
└── Span: POST /api/checkout [Service: api-gateway]
    ├── Span: validate_cart [Service: cart-service]
    │   └── Span: SELECT * FROM carts [DB: postgres]
    ├── Span: create_order [Service: order-service]
    │   ├── Span: INSERT INTO orders [DB: mongodb]
    │   └── Span: publish_event [Message: rabbitmq]
    ├── Span: reserve_inventory [Service: inventory-service]
    │   └── Span: UPDATE products [DB: postgres]
    └── Span: process_payment [Service: payment-service]
        └── Span: POST /charge [External: stripe-api]
```

**Implementa con Spring Cloud Sleuth:**

```java
@Service
public class OrderService {
    
    private final Tracer tracer;
    
    public Order createOrder(OrderRequest request) {
        Span span = tracer.nextSpan().name("create_order");
        
        try (Tracer.SpanInScope ws = tracer.withSpan(span.start())) {
            // TODO: Añadir tags relevantes
            span.tag("order.user_id", request.getUserId());
            span.tag("order.total", request.getTotal().toString());
            
            // Lógica de creación
            Order order = processOrder(request);
            
            span.tag("order.id", order.getId());
            span.event("order.created");
            
            return order;
        } finally {
            span.end();
        }
    }
}
```

**Preguntas:**
1. ¿Qué información adicional incluirías en los tags?
2. ¿Cómo usarías los traces para debugging?
3. ¿Qué span sería el más lento típicamente?

---

#### Parte C: Dashboard de Grafana

Diseña un dashboard para monitorear la salud del sistema.

**Paneles requeridos:**

1. **Health Overview**
   - Disponibilidad por servicio (%)
   - Estado de circuit breakers
   - Tasa de errores global

2. **Performance**
   - Latencia P50/P95/P99 por servicio
   - Throughput (req/s)
   - Tiempo de respuesta de BD

3. **Business Metrics**
   - Órdenes creadas (últimas 24h)
   - Revenue generado
   - Tasa de conversión

4. **Infrastructure**
   - CPU/Memoria por servicio
   - Número de pods activos
   - Costo estimado

**Ejemplo de query PromQL:**

```promql
# Latencia P95 del Order Service
histogram_quantile(0.95,
  sum(rate(http_server_requests_seconds_bucket{
    uri="/api/orders",
    service="order-service"
  }[5m])) by (le)
)

# Tasa de error
sum(rate(http_server_requests_seconds_count{
  status=~"5..",
  service="order-service"
}[5m]))
/
sum(rate(http_server_requests_seconds_count{
  service="order-service"
}[5m]))
```

**Configura alertas para:**
- Latencia P95 > 1 segundo
- Tasa de error > 5%
- Circuit breaker abierto > 5 minutos
- CPU > 80% por más de 10 minutos

---

## EJERCICIO 7: CHAOS ENGINEERING

### Objetivo
Validar la resiliencia del sistema mediante pruebas de caos controladas.

### Actividad (60 minutos)

#### Experimentos de Caos a Diseñar

**Experimento 1: Latencia en Inventory Service**

```yaml
# chaos-latency.yaml
apiVersion: chaos-mesh.org/v1alpha1
kind: NetworkChaos
metadata:
  name: inventory-latency
spec:
  action: delay
  mode: one
  selector:
    namespaces:
      - production
    labelSelectors:
      app: inventory-service
  delay:
    latency: "2s"
    correlation: "100"
  duration: "5m"
```

**Hipótesis:**
- El Order Service debe tolerar 2s de latencia en Inventory
- Circuit breaker NO debe abrirse
- Usuarios reciben respuesta en < 5s

**¿Cómo validarías la hipótesis?**

---

**Experimento 2: Pod Termination**

```yaml
apiVersion: chaos-mesh.org/v1alpha1
kind: PodChaos
metadata:
  name: kill-payment-pod
spec:
  action: pod-kill
  mode: one
  selector:
    namespaces:
      - production
    labelSelectors:
      app: payment-service
  scheduler:
    cron: "*/5 * * * *"  # Cada 5 minutos
```

**Hipótesis:**
- Kubernetes reemplaza el pod en < 30s
- Requests en curso fallan con 503
- Circuit breaker se activa temporalmente
- Recovery automático en < 1 minuto

---

**Experimento 3: Database Failure**

Simula que la base de datos del Order Service se vuelve lenta:

**Pregunta:** ¿Qué debería pasar?
- [ ] Todo el sistema falla
- [ ] Solo Order Service afectado
- [ ] Circuit breakers protegen otros servicios
- [ ] Fallbacks permiten operación degradada

**Implementa:**
- Timeout en conexiones de BD
- Circuit breaker para queries
- Fallback: usar cache si está disponible

---

## RÚBRICA DE EVALUACIÓN

### Ejercicio 1: Análisis (20 puntos)
- Identificación correcta de problemas: 10 pts
- Profundidad del análisis: 5 pts
- Propuestas de solución viables: 5 pts

### Ejercicio 2: Circuit Breaker (15 puntos)
- Configuración apropiada: 7 pts
- Implementación de fallback: 5 pts
- Manejo de casos edge: 3 pts

### Ejercicio 3: Microservicios (20 puntos)
- Descomposición lógica: 8 pts
- Diseño de comunicación: 7 pts
- Manejo de consistencia: 5 pts

### Ejercicio 4: Saga Pattern (15 puntos)
- Implementación correcta: 7 pts
- Manejo de compensaciones: 5 pts
- Idempotencia: 3 pts

### Ejercicio 5: Auto-scaling (15 puntos)
- Configuración HPA: 7 pts
- Justificación de decisiones: 5 pts
- Plan de pruebas: 3 pts

### Ejercicio 6: Observabilidad (10 puntos)
- Métricas implementadas: 4 pts
- Distributed tracing: 3 pts
- Dashboard diseñado: 3 pts

### Ejercicio 7: Chaos Engineering (5 puntos)
- Diseño de experimentos: 3 pts
- Validación de hipótesis: 2 pts

---

## RECURSOS ADICIONALES

### Lecturas Recomendadas
1. [The Reactive Manifesto](https://www.reactivemanifesto.org/)
2. [Microservices Patterns - Chris Richardson](https://microservices.io/patterns/)
3. [Release It! - Michael Nygard](https://www.oreilly.com/library/view/release-it-2nd/9781680504552/)

### Herramientas
- Spring Cloud: Circuit Breaker, Sleuth, Gateway
- Resilience4j: Patterns de resiliencia
- Kubernetes: Orquestación y auto-scaling
- Prometheus + Grafana: Métricas y visualización
- RabbitMQ: Message broker
- Chaos Mesh: Chaos engineering en Kubernetes

### Código de Ejemplo
Repositorio con implementación completa: [github.com/mercadorapido/reactive-ecommerce](https://github.com)

---

## CONCLUSIÓN

Estos ejercicios cubren el espectro completo de transformar un monolito frágil en un sistema reactivo resiliente. Al completarlos, habrás practicado:

✅ Análisis de limitaciones
✅ Implementación de patrones de resiliencia
✅ Descomposición en microservicios
✅ Manejo de transacciones distribuidas
✅ Configuración de auto-scaling
✅ Observabilidad end-to-end
✅ Validación con chaos engineering

**¡Éxito en tus prácticas!**
