# Caso de Uso: Sistema de E-Commerce "MercadoRápido"
## Aplicaciones y Sistemas Escalables

---

## 1. CONTEXTO DEL NEGOCIO

**MercadoRápido** es una plataforma de comercio electrónico que vende productos de moda, tecnología y hogar en América Latina.

### Métricas Actuales
- **Tráfico normal**: 10,000 usuarios concurrentes
- **Transacciones diarias**: 50,000 órdenes
- **Catálogo**: 100,000 productos
- **Base de usuarios**: 2 millones registrados

### Picos Estacionales
- **Black Friday**: 150,000 usuarios concurrentes (15x)
- **Navidad**: 100,000 usuarios concurrentes (10x)
- **San Valentín**: 80,000 usuarios concurrentes (8x)
- **Día de la Madre**: 90,000 usuarios concurrentes (9x)

---

## 2. ARQUITECTURA MONOLÍTICA ACTUAL

### 2.1 Descripción del Monolito

```
┌─────────────────────────────────────────────────────┐
│           APLICACIÓN MONOLÍTICA (Java/Spring)       │
├─────────────────────────────────────────────────────┤
│  ┌──────────────┐  ┌──────────────┐  ┌───────────┐│
│  │   Catálogo   │  │   Carrito    │  │  Usuarios ││
│  └──────────────┘  └──────────────┘  └───────────┘│
│  ┌──────────────┐  ┌──────────────┐  ┌───────────┐│
│  │   Órdenes    │  │    Pagos     │  │  Inventar││
│  └──────────────┘  └──────────────┘  └───────────┘│
│  ┌──────────────┐  ┌──────────────┐  ┌───────────┐│
│  │Notificaciones│  │   Búsqueda   │  │ Reportes  ││
│  └──────────────┘  └──────────────┘  └───────────┘│
└─────────────────────────────────────────────────────┘
                        │
                        ▼
        ┌───────────────────────────────┐
        │   Base de Datos PostgreSQL    │
        │        (Única instancia)       │
        └───────────────────────────────┘
```

### 2.2 Stack Tecnológico
- **Backend**: Spring Boot monolítico (JAR único)
- **Base de datos**: PostgreSQL (instancia única)
- **Cache**: Redis (opcional, poco usado)
- **Servidor**: Tomcat embebido
- **Deployment**: 3 servidores con load balancer

---

## 3. PROBLEMAS IDENTIFICADOS (LÍMITES DEL MONOLITO)

### 3.1 Incidente de Black Friday 2024

**Cronología del desastre:**

```
09:00 AM - Inicio de ofertas
09:15 AM - Tiempo de respuesta sube de 200ms a 2 segundos
09:30 AM - Usuarios reportan errores de "timeout"
09:45 AM - CPU de servidores al 95%
10:00 AM - Base de datos alcanza conexiones máximas (500)
10:15 AM - Sistema COMPLETAMENTE CAÍDO
10:30 AM - Pérdidas estimadas: $50,000 USD/hora
```

### 3.2 Análisis de Problemas Específicos

#### Problema 1: Acoplamiento de Funcionalidades
**Síntoma**: Un bug en el módulo de reportes consumía memoria excesiva, afectando TODAS las funcionalidades.

```
Reportes (20% CPU) → Inventario (fail) → Órdenes (fail) → Pagos (fail)
```

**Impacto**: El 100% del sistema caído por un módulo que solo el 5% de usuarios usa.

#### Problema 2: Contención de Base de Datos
**Síntoma**: Consultas lentas de reportes bloqueaban transacciones de órdenes.

```sql
-- Query de reportes (60 segundos)
SELECT p.*, SUM(oi.quantity) 
FROM products p 
JOIN order_items oi ON p.id = oi.product_id
WHERE created_at BETWEEN '2024-01-01' AND '2024-12-31'
GROUP BY p.id;

-- Bloqueaba inserts de órdenes nuevas
INSERT INTO orders (user_id, total, ...) VALUES (...);
```

#### Problema 3: Escalamiento Ineficiente
**Síntoma**: Para escalar búsqueda (alta demanda), tenían que replicar TODO el monolito.

```
Necesidad: 10x capacidad en Búsqueda y Catálogo
Solución forzada: 10x TODA la aplicación
Costo: $5,000/mes → $50,000/mes
Eficiencia: 20% (solo 2 módulos de 10 lo necesitaban)
```

#### Problema 4: Despliegue Riesgoso
**Problema**: Un hotfix para pagos requería redesplegar toda la aplicación.

```
Feature: Nuevo método de pago
Afectación: 15 minutos de downtime TOTAL
Riesgo: Cualquier bug afecta todo el sistema
```

#### Problema 5: Falta de Resiliencia
**Síntoma**: Si el servicio de notificaciones fallaba, las órdenes no se completaban.

```java
public Order createOrder(OrderRequest request) {
    Order order = orderRepository.save(request);
    inventoryService.decreaseStock(order.getItems()); // ❌ Bloqueante
    paymentService.processPayment(order);             // ❌ Bloqueante
    notificationService.sendEmail(order);             // ❌ Bloqueante, FALLA
    // ⚠️ Si notificaciones falla → toda la transacción falla
    return order;
}
```

---

## 4. GESTIÓN DEL MONOLITO ANTES DE LA MIGRACIÓN

### 4.1 Optimizaciones Inmediatas (Wins Rápidos)

#### A. Implementación de Circuit Breaker
```java
@Service
public class OrderService {
    
    @CircuitBreaker(name = "notifications", fallbackMethod = "fallbackNotification")
    public Order createOrder(OrderRequest request) {
        Order order = orderRepository.save(request);
        inventoryService.decreaseStock(order.getItems());
        paymentService.processPayment(order);
        notificationService.sendEmail(order); // Protegido por Circuit Breaker
        return order;
    }
    
    private Order fallbackNotification(OrderRequest request, Exception e) {
        // Encolar notificación para retry asíncrono
        notificationQueue.enqueue(order.getId());
        return order; // ✅ Orden se completa aunque notificación falle
    }
}
```

**Resultado**: Reducción de errores de órdenes del 15% al 2%.

#### B. Separación de Lecturas y Escrituras (CQRS Básico)
```
┌─────────────────┐         ┌──────────────────┐
│  PostgreSQL     │         │  Read Replicas   │
│  (Escrituras)   │────────▶│  (Lecturas)      │
│  Master         │         │  Slaves (3)      │
└─────────────────┘         └──────────────────┘
         │                           │
         ▼                           ▼
    Órdenes, Pagos              Búsquedas, Reportes
    Inventario                  Catálogo, Dashboards
```

**Resultado**: Reducción de carga en DB principal del 70%.

#### C. Cache Estratégico
```java
@Cacheable(value = "products", key = "#productId")
public Product getProduct(Long productId) {
    return productRepository.findById(productId);
}

@Cacheable(value = "catalog", key = "#category")
public List<Product> getProductsByCategory(String category) {
    return productRepository.findByCategory(category);
}
```

**Configuración Redis:**
- TTL productos: 1 hora
- TTL categorías: 30 minutos
- Invalidación en cambios de inventario

**Resultado**: Hit rate 85%, reducción de consultas a DB en 60%.

#### D. Procesamiento Asíncrono
```java
// Antes: Todo síncrono
public Order createOrder(OrderRequest request) {
    Order order = saveOrder(request);
    sendEmail(order);           // ❌ Bloqueante
    generateInvoice(order);     // ❌ Bloqueante
    updateAnalytics(order);     // ❌ Bloqueante
    return order;
}

// Después: Tareas no críticas asíncronas
public Order createOrder(OrderRequest request) {
    Order order = saveOrder(request);
    
    // ✅ Tareas asíncronas con RabbitMQ
    messagingService.publish("order.created", order);
    
    return order; // Respuesta inmediata
}

@RabbitListener(queues = "order.created")
public void handleOrderCreated(Order order) {
    sendEmail(order);
    generateInvoice(order);
    updateAnalytics(order);
}
```

**Resultado**: Tiempo de respuesta de creación de órdenes: 3s → 300ms.

### 4.2 Límites Definidos del Monolito

| Métrica | Límite Identificado | Razón |
|---------|-------------------|-------|
| Usuarios concurrentes | 50,000 | CPU al 90%, latencia >2s |
| Órdenes/segundo | 500 | Contención de DB |
| Tamaño del código | 200,000 LOC | Mantenibilidad crítica |
| Tiempo de build | 15 minutos | Feedback loop muy lento |
| Equipo de desarrollo | 20 devs | Merge conflicts constantes |

**Conclusión**: El monolito puede soportar operación normal, pero NO puede crecer más allá de estos límites.

---

## 5. EVOLUCIÓN HACIA ARQUITECTURA REACTIVA

### 5.1 Principios del Manifiesto Reactivo Aplicados

#### **1. RESPONSIVE (Responsivo)**
*El sistema responde rápidamente en todas las circunstancias.*

**Implementación:**
```
┌─────────────────────────────────────────┐
│     API Gateway (Timeout: 5s)           │
└────────────┬────────────────────────────┘
             │
    ┌────────┴────────┬──────────────┐
    ▼                 ▼              ▼
┌─────────┐      ┌─────────┐    ┌─────────┐
│Catálogo │      │Órdenes  │    │Pagos    │
│Service  │      │Service  │    │Service  │
│ SLA:200ms│     │SLA:500ms│    │SLA:1s   │
└─────────┘      └─────────┘    └─────────┘
```

**Métricas de éxito:**
- P95 latencia < 500ms
- P99 latencia < 1s
- Disponibilidad > 99.9%

#### **2. RESILIENT (Resiliente)**
*El sistema permanece responsivo ante fallos.*

**Patrones implementados:**

**A. Circuit Breaker Pattern**
```java
@Service
public class OrderService {
    
    @CircuitBreaker(
        name = "payment",
        fallbackMethod = "fallbackPayment"
    )
    public PaymentResult processPayment(Order order) {
        return paymentClient.charge(order.getTotal());
    }
    
    private PaymentResult fallbackPayment(Order order, Exception e) {
        // ✅ Degradación elegante
        return PaymentResult.pending("Pago en proceso, recibirás confirmación");
    }
}
```

**Estados del Circuit Breaker:**
```
CLOSED (Normal) → OPEN (Fallo) → HALF_OPEN (Prueba) → CLOSED
    │                  │                │
    └──────────────────┴────────────────┘
    
Configuración:
- Threshold: 50% errores en 10 requests
- Timeout: 30 segundos
- Half-open: 3 requests de prueba
```

**B. Bulkhead Pattern**
```java
@Configuration
public class ThreadPoolConfig {
    
    @Bean("ordersExecutor")
    public Executor ordersExecutor() {
        ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();
        executor.setCorePoolSize(20);
        executor.setMaxPoolSize(50);
        executor.setQueueCapacity(100);
        return executor;
    }
    
    @Bean("searchExecutor")
    public Executor searchExecutor() {
        ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();
        executor.setCorePoolSize(50);  // Más threads para búsqueda
        executor.setMaxPoolSize(100);
        executor.setQueueCapacity(500);
        return executor;
    }
}
```

**Resultado**: Si búsqueda se satura, órdenes continúan funcionando.

**C. Retry con Backoff Exponencial**
```java
@Retryable(
    value = {TransientException.class},
    maxAttempts = 3,
    backoff = @Backoff(delay = 1000, multiplier = 2)
)
public InventoryResponse updateInventory(Long productId, int quantity) {
    return inventoryClient.update(productId, quantity);
}

// Intento 1: Inmediato
// Intento 2: 1 segundo después
// Intento 3: 2 segundos después
// Fallo final: Fallback o error
```

#### **3. ELASTIC (Elástico)**
*El sistema se adapta a la carga de trabajo.*

**A. Auto-scaling basado en métricas**
```yaml
# Kubernetes HPA (Horizontal Pod Autoscaler)
apiVersion: autoscaling/v2
kind: HorizontalPodAutoscaler
metadata:
  name: catalog-service-hpa
spec:
  scaleTargetRef:
    apiVersion: apps/v1
    kind: Deployment
    name: catalog-service
  minReplicas: 2
  maxReplicas: 20
  metrics:
  - type: Resource
    resource:
      name: cpu
      target:
        type: Utilization
        averageUtilization: 70
  - type: Pods
    pods:
      metric:
        name: http_requests_per_second
      target:
        type: AverageValue
        averageValue: "1000"
```

**B. Escalamiento por módulo**
```
Temporada Normal:
┌──────────┐ ┌──────────┐ ┌──────────┐
│Catálogo  │ │Órdenes   │ │Pagos     │
│x2 pods   │ │x2 pods   │ │x2 pods   │
└──────────┘ └──────────┘ └──────────┘
Costo: $2,000/mes

Black Friday:
┌──────────────────────────────────┐
│Catálogo (búsqueda intensiva)     │
│x20 pods ← SOLO este escala       │
└──────────────────────────────────┘
┌──────────┐ ┌──────────┐
│Órdenes   │ │Pagos     │
│x5 pods   │ │x3 pods   │
└──────────┘ └──────────┘
Costo: $8,000/mes (vs $50,000 del monolito)
```

#### **4. MESSAGE-DRIVEN (Orientado a Mensajes)**
*Componentes interactúan mediante mensajes asíncronos.*

**Arquitectura de Mensajería:**
```
┌─────────────┐
│  Order API  │
└──────┬──────┘
       │ 1. POST /orders
       ▼
┌─────────────────┐
│ Order Service   │
│ (Produce evento)│
└────────┬────────┘
         │ order.created
         ▼
    ┌────────────────┐
    │  RabbitMQ      │
    │  Event Bus     │
    └────┬───┬───┬───┘
         │   │   │
    ┌────▼───▼───▼────────────────────┐
    │                                  │
┌───▼─────────┐ ┌────▼────────┐ ┌────▼────────┐
│Inventory    │ │Notification │ │Analytics    │
│Service      │ │Service      │ │Service      │
│(Consume)    │ │(Consume)    │ │(Consume)    │
└─────────────┘ └─────────────┘ └─────────────┘
```

**Eventos definidos:**
```json
{
  "eventType": "order.created",
  "eventId": "uuid-1234",
  "timestamp": "2024-11-15T10:30:00Z",
  "payload": {
    "orderId": 12345,
    "userId": 789,
    "items": [...],
    "total": 150.00
  },
  "metadata": {
    "source": "order-service",
    "version": "1.0"
  }
}
```

**Ventajas:**
- ✅ Desacoplamiento temporal (servicios no necesitan estar disponibles simultáneamente)
- ✅ Desacoplamiento de localización (no importa dónde está el consumidor)
- ✅ Reintento automático en fallos
- ✅ Procesamiento asíncrono
- ✅ Múltiples consumidores por evento

---

## 6. ARQUITECTURA TARGET (MICROSERVICIOS REACTIVOS)

### 6.1 Descomposición del Monolito

**Estrategia: Strangler Fig Pattern**
```
Fase 1: Extraer servicios de lectura (bajo riesgo)
  → Catálogo Service
  → Búsqueda Service
  
Fase 2: Extraer servicios de negocio crítico
  → Order Service
  → Payment Service
  
Fase 3: Extraer servicios de soporte
  → Notification Service
  → Analytics Service
  
Fase 4: Retirar monolito
```

### 6.2 Arquitectura Final

```
                    ┌──────────────────┐
                    │   API Gateway    │
                    │   (Kong/Zuul)    │
                    └────────┬─────────┘
                             │
        ┌────────────────────┼────────────────────┐
        │                    │                    │
┌───────▼─────────┐  ┌──────▼──────┐  ┌─────────▼─────┐
│ Catalog Service │  │Order Service│  │Payment Service│
│  (Spring Boot)  │  │ (Spring Boot│  │  (Node.js)    │
│  PostgreSQL     │  │  MongoDB    │  │  PostgreSQL   │
│  Redis Cache    │  │  RabbitMQ   │  │               │
└─────────────────┘  └─────────────┘  └───────────────┘
        │                    │                    │
        └────────────────────┼────────────────────┘
                             ▼
                    ┌────────────────┐
                    │   Event Bus    │
                    │   (RabbitMQ)   │
                    └────────┬───────┘
                             │
        ┌────────────────────┼────────────────────┐
        │                    │                    │
┌───────▼──────────┐ ┌──────▼─────────┐ ┌───────▼──────────┐
│Inventory Service │ │Notification    │ │Analytics Service │
│  (Go)            │ │Service         │ │  (Python)        │
│  PostgreSQL      │ │  (Node.js)     │ │  ClickHouse      │
└──────────────────┘ └────────────────┘ └──────────────────┘
```

### 6.3 Tecnologías por Servicio

| Servicio | Tecnología | Base de Datos | Razón |
|----------|-----------|---------------|-------|
| Catalog | Spring Boot | PostgreSQL + Redis | Lectura intensiva, cache efectivo |
| Search | Elasticsearch | Elasticsearch | Búsqueda full-text optimizada |
| Order | Spring Boot | MongoDB | Escalabilidad horizontal, documentos flexibles |
| Payment | Node.js | PostgreSQL | I/O asíncrono, integraciones externas |
| Inventory | Go | PostgreSQL | Alta concurrencia, bajo latencia |
| Notification | Node.js | - | Event-driven, I/O asíncrono |
| Analytics | Python | ClickHouse | Procesamiento de datos, columnar DB |

---

## 7. IMPLEMENTACIÓN PRÁCTICA

### 7.1 Ejemplo: Order Service Reactivo

```java
@RestController
@RequestMapping("/api/orders")
public class OrderController {
    
    @Autowired
    private OrderService orderService;
    
    @PostMapping
    @CircuitBreaker(name = "orderCreation", fallbackMethod = "fallbackCreateOrder")
    @RateLimiter(name = "orderCreation")
    public Mono<ResponseEntity<OrderResponse>> createOrder(
        @RequestBody OrderRequest request
    ) {
        return orderService.createOrder(request)
            .map(order -> ResponseEntity.ok(new OrderResponse(order)))
            .timeout(Duration.ofSeconds(5))
            .onErrorResume(this::handleError);
    }
    
    private Mono<ResponseEntity<OrderResponse>> fallbackCreateOrder(
        OrderRequest request, Exception e
    ) {
        return Mono.just(
            ResponseEntity.status(503)
                .body(new OrderResponse("Sistema temporalmente no disponible"))
        );
    }
}

@Service
public class OrderService {
    
    @Autowired
    private OrderRepository orderRepository;
    
    @Autowired
    private InventoryClient inventoryClient;
    
    @Autowired
    private EventPublisher eventPublisher;
    
    @Transactional
    public Mono<Order> createOrder(OrderRequest request) {
        return Mono.fromCallable(() -> validateOrder(request))
            .flatMap(valid -> reserveInventory(request.getItems()))
            .flatMap(reserved -> saveOrder(request))
            .doOnSuccess(order -> publishOrderCreatedEvent(order))
            .doOnError(error -> handleOrderError(error));
    }
    
    private Mono<Boolean> reserveInventory(List<OrderItem> items) {
        return inventoryClient.reserve(items)
            .timeout(Duration.ofSeconds(3))
            .retry(2)  // Retry 2 veces
            .onErrorResume(e -> {
                // Si falla inventario, continuamos pero marcamos para verificación manual
                log.warn("Inventory reservation failed, creating order for manual review", e);
                return Mono.just(false);
            });
    }
    
    private void publishOrderCreatedEvent(Order order) {
        OrderCreatedEvent event = new OrderCreatedEvent(
            order.getId(),
            order.getUserId(),
            order.getItems(),
            order.getTotal()
        );
        eventPublisher.publish("order.created", event);
    }
}
```

### 7.2 Configuración de Resiliencia

```yaml
# application.yml
resilience4j:
  circuitbreaker:
    instances:
      orderCreation:
        slidingWindowSize: 10
        failureRateThreshold: 50
        waitDurationInOpenState: 30s
        permittedNumberOfCallsInHalfOpenState: 3
        
  ratelimiter:
    instances:
      orderCreation:
        limitForPeriod: 100
        limitRefreshPeriod: 1s
        timeoutDuration: 0s
        
  retry:
    instances:
      inventoryService:
        maxAttempts: 3
        waitDuration: 1s
        exponentialBackoffMultiplier: 2
```

### 7.3 Monitoreo y Observabilidad

```java
@Component
public class OrderMetrics {
    
    private final MeterRegistry meterRegistry;
    
    public OrderMetrics(MeterRegistry meterRegistry) {
        this.meterRegistry = meterRegistry;
    }
    
    public void recordOrderCreated(Order order) {
        meterRegistry.counter("orders.created",
            "status", "success",
            "total_range", getRange(order.getTotal())
        ).increment();
    }
    
    public void recordOrderFailed(String reason) {
        meterRegistry.counter("orders.failed",
            "reason", reason
        ).increment();
    }
    
    public void recordOrderLatency(long milliseconds) {
        meterRegistry.timer("orders.latency").record(
            Duration.ofMillis(milliseconds)
        );
    }
}
```

**Dashboard de Grafana:**
```
┌─────────────────────────────────────────┐
│  MercadoRápido - Order Service          │
├─────────────────────────────────────────┤
│  Requests/sec: 1,234 ▲ 15%             │
│  Avg Latency: 245ms  ▼ 8%              │
│  Error Rate: 0.5%    ▼ 50%             │
│  Circuit Breaker: CLOSED ✓              │
├─────────────────────────────────────────┤
│  [Gráfico de latencia P50/P95/P99]     │
│  [Gráfico de tasa de errores]          │
│  [Gráfico de throughput]               │
└─────────────────────────────────────────┘
```

---

## 8. RESULTADOS Y MÉTRICAS

### 8.1 Comparación Antes/Después

| Métrica | Monolito | Microservicios Reactivos | Mejora |
|---------|----------|-------------------------|--------|
| **Escalabilidad** |
| Usuarios concurrentes | 50,000 | 500,000 | 10x |
| Órdenes/segundo | 500 | 5,000 | 10x |
| Costo por usuario | $0.10 | $0.02 | 80% reducción |
| **Resiliencia** |
| Disponibilidad | 99.5% | 99.95% | +0.45% |
| MTTR (Mean Time To Recovery) | 15 min | 2 min | 87% reducción |
| Incidentes críticos/mes | 8 | 1 | 87% reducción |
| **Performance** |
| P95 Latencia | 2s | 400ms | 80% reducción |
| P99 Latencia | 5s | 800ms | 84% reducción |
| **Desarrollo** |
| Tiempo de deployment | 15 min | 2 min | 87% reducción |
| Frecuencia de deploys | 2/semana | 50/semana | 25x |
| Time to market | 4 semanas | 1 semana | 75% reducción |

### 8.2 Black Friday 2025 (Post-Migración)

```
09:00 AM - Inicio de ofertas
          - Auto-scaling activado: Catalog 2→20 pods (2 minutos)
09:30 AM - Pico de tráfico: 180,000 usuarios concurrentes
          - Latencia P95: 450ms ✓
          - Error rate: 0.3% ✓
12:00 PM - Pico de ventas: 8,000 órdenes/segundo
          - Sistema 100% operativo ✓
          - Cero incidentes críticos ✓
05:00 PM - Fin de ofertas
          - Auto-scaling desactivado: Catalog 20→4 pods
          
Resultado: $2.5M en ventas (vs $0 del año anterior)
Ahorro en infraestructura: $42,000 vs monolito escalado
```

---

## 9. LECCIONES APRENDIDAS

### 9.1 Qué Funcionó Bien

✅ **Strangler Fig Pattern**: Migración gradual minimizó riesgo
✅ **Event-Driven Architecture**: Desacoplamiento real de servicios
✅ **Circuit Breakers**: Prevención de cascading failures
✅ **Auto-scaling**: Elasticidad real y ahorro de costos
✅ **Observabilidad**: Detección temprana de problemas

### 9.2 Desafíos Enfrentados

⚠️ **Transacciones distribuidas**: Implementar sagas fue complejo
⚠️ **Consistencia eventual**: Requirió educación de stakeholders
⚠️ **Overhead operacional**: Más servicios = más complejidad de operación
⚠️ **Testing**: Necesidad de contract testing y chaos engineering
⚠️ **Networking**: Latencia entre servicios requirió optimización

### 9.3 Recomendaciones

1. **No migrar todo a la vez**: Empezar por servicios de lectura
2. **Invertir en observabilidad desde día 1**: Imposible operar sin métricas
3. **Automatizar todo**: CI/CD, testing, scaling, alerting
4. **Documentar contratos de API**: Evitar breaking changes
5. **Capacitar al equipo**: Nuevos patrones requieren nueva mentalidad

---

## 10. EJERCICIOS PRÁCTICOS PARA LA CLASE

### Ejercicio 1: Identificar Límites
Analizar el monolito actual de MercadoRápido e identificar:
- Bottlenecks de performance
- Puntos únicos de fallo
- Módulos que requieren escalamiento diferenciado

### Ejercicio 2: Diseñar Circuit Breaker
Implementar un circuit breaker para el servicio de pagos considerando:
- Threshold de fallo
- Timeout de recuperación
- Estrategia de fallback

### Ejercicio 3: Modelar Eventos
Diseñar el flujo de eventos para el proceso de checkout:
- Identificar eventos de negocio
- Definir productores y consumidores
- Manejar compensación en fallos

### Ejercicio 4: Definir SLAs
Establecer SLAs para cada servicio basados en:
- Criticidad del negocio
- Expectativas de usuario
- Capacidad técnica

### Ejercicio 5: Estrategia de Escalamiento
Diseñar una estrategia de auto-scaling para Black Friday:
- Métricas a monitorear
- Triggers de escalamiento
- Límites de recursos

---

## CONCLUSIÓN

La evolución de MercadoRápido de un monolito a una arquitectura de microservicios reactivos demuestra cómo la aplicación de los principios del Manifiesto Reactivo (Responsive, Resilient, Elastic, Message-Driven) puede transformar un sistema que apenas sobrevive en temporadas altas a uno que prospera bajo presión extrema.

**Puntos clave:**
- El monolito no es inherentemente malo, pero tiene límites claros
- La migración debe ser gradual y basada en valor de negocio
- Los principios reactivos son fundamentales para sistemas modernos a escala
- La observabilidad es crítica para operar sistemas distribuidos
- El éxito requiere cambio técnico Y cultural

**Próximos pasos:**
- Implementar chaos engineering para validar resiliencia
- Optimizar costos con spot instances
- Expandir a otras regiones geográficas
- Explorar serverless para cargas variables
