# Guía de Implementación Práctica
## MercadoRápido - Código y Arquitecturas Detalladas

---

## 1. CÓDIGO DEL MONOLITO (ANTES)

### 1.1 Controlador Monolítico

```java
// OrderController.java - Ejemplo del ANTI-PATRÓN
@RestController
@RequestMapping("/api/orders")
public class OrderController {
    
    @Autowired
    private OrderRepository orderRepository;
    
    @Autowired
    private InventoryRepository inventoryRepository;
    
    @Autowired
    private PaymentService paymentService;
    
    @Autowired
    private EmailService emailService;
    
    @Autowired
    private AnalyticsService analyticsService;
    
    // ❌ PROBLEMA: Todo acoplado, bloqueante, sin resiliencia
    @PostMapping
    public ResponseEntity<Order> createOrder(@RequestBody OrderRequest request) {
        // 1. Validación
        if (!validateOrder(request)) {
            return ResponseEntity.badRequest().build();
        }
        
        // 2. Verificar inventario - BLOQUEANTE
        for (OrderItem item : request.getItems()) {
            Product product = inventoryRepository.findById(item.getProductId())
                .orElseThrow(() -> new ProductNotFoundException());
            
            if (product.getStock() < item.getQuantity()) {
                throw new InsufficientStockException(); // ❌ Falla toda la operación
            }
            
            // Actualizar stock - LOCK en BD
            product.setStock(product.getStock() - item.getQuantity());
            inventoryRepository.save(product); // ❌ N+1 queries
        }
        
        // 3. Crear orden
        Order order = new Order();
        order.setUserId(request.getUserId());
        order.setItems(request.getItems());
        order.setTotal(calculateTotal(request.getItems()));
        order.setStatus("PENDING");
        order = orderRepository.save(order);
        
        // 4. Procesar pago - BLOQUEANTE, SIN TIMEOUT
        try {
            PaymentResult payment = paymentService.processPayment(
                order.getTotal(),
                request.getPaymentMethod()
            ); // ❌ Si el servicio externo está lento, TODO se bloquea
            
            if (!payment.isSuccess()) {
                throw new PaymentFailedException();
            }
            
            order.setStatus("PAID");
            order.setPaymentId(payment.getPaymentId());
            orderRepository.save(order);
            
        } catch (Exception e) {
            // ❌ Rollback manual, propenso a inconsistencias
            rollbackInventory(request.getItems());
            throw new PaymentProcessingException(e);
        }
        
        // 5. Enviar email - BLOQUEANTE
        try {
            emailService.sendOrderConfirmation(order); // ❌ Si falla, falla TODO
        } catch (Exception e) {
            log.error("Failed to send email", e);
            // ⚠️ Continuamos pero el usuario no recibe confirmación
        }
        
        // 6. Actualizar analytics - BLOQUEANTE
        try {
            analyticsService.trackOrder(order); // ❌ No crítico pero bloquea
        } catch (Exception e) {
            log.error("Failed to track analytics", e);
        }
        
        return ResponseEntity.ok(order);
    }
    
    private void rollbackInventory(List<OrderItem> items) {
        // ❌ Código de compensación manual, frágil
        for (OrderItem item : items) {
            Product product = inventoryRepository.findById(item.getProductId()).get();
            product.setStock(product.getStock() + item.getQuantity());
            inventoryRepository.save(product);
        }
    }
}
```

**Problemas identificados:**
1. ❌ Todo síncrono y bloqueante
2. ❌ Sin timeouts - puede colgar indefinidamente
3. ❌ Sin circuit breakers - cascading failures
4. ❌ N+1 queries - ineficiente
5. ❌ Compensación manual - propenso a errores
6. ❌ Tareas no críticas bloquean el flujo
7. ❌ Sin retry logic
8. ❌ Un solo punto de fallo

---

## 2. CÓDIGO REACTIVO (DESPUÉS)

### 2.1 Order Service - Microservicio Reactivo

```java
// OrderController.java - VERSIÓN REACTIVA
@RestController
@RequestMapping("/api/orders")
@Slf4j
public class OrderController {
    
    private final OrderService orderService;
    private final MeterRegistry meterRegistry;
    
    public OrderController(OrderService orderService, MeterRegistry meterRegistry) {
        this.orderService = orderService;
        this.meterRegistry = meterRegistry;
    }
    
    @PostMapping
    @CircuitBreaker(name = "createOrder", fallbackMethod = "createOrderFallback")
    @RateLimiter(name = "createOrder")
    @Bulkhead(name = "createOrder", type = Bulkhead.Type.THREADPOOL)
    public Mono<ResponseEntity<OrderResponse>> createOrder(
        @RequestBody @Valid OrderRequest request,
        @RequestHeader("X-User-Id") String userId
    ) {
        long startTime = System.currentTimeMillis();
        
        return orderService.createOrder(request, userId)
            .map(order -> {
                recordMetrics("success", startTime);
                return ResponseEntity.ok(OrderResponse.from(order));
            })
            .timeout(Duration.ofSeconds(5)) // ✅ Timeout global
            .onErrorResume(TimeoutException.class, e -> {
                recordMetrics("timeout", startTime);
                return Mono.just(ResponseEntity.status(504)
                    .body(new OrderResponse("Request timeout, please try again")));
            })
            .onErrorResume(InsufficientStockException.class, e -> {
                recordMetrics("insufficient_stock", startTime);
                return Mono.just(ResponseEntity.status(409)
                    .body(new OrderResponse("Insufficient stock for requested items")));
            })
            .onErrorResume(e -> {
                recordMetrics("error", startTime);
                log.error("Error creating order", e);
                return Mono.just(ResponseEntity.status(500)
                    .body(new OrderResponse("Error processing order")));
            });
    }
    
    // ✅ Fallback cuando el circuit breaker se abre
    private Mono<ResponseEntity<OrderResponse>> createOrderFallback(
        OrderRequest request,
        String userId,
        Exception e
    ) {
        log.warn("Circuit breaker activated for order creation", e);
        recordMetrics("circuit_breaker_open", 0);
        
        return Mono.just(ResponseEntity.status(503)
            .body(new OrderResponse(
                "Service temporarily unavailable. Please try again in a moment."
            )));
    }
    
    private void recordMetrics(String status, long startTime) {
        meterRegistry.counter("orders.created",
            "status", status
        ).increment();
        
        if (startTime > 0) {
            meterRegistry.timer("orders.latency",
                "status", status
            ).record(Duration.ofMillis(System.currentTimeMillis() - startTime));
        }
    }
}
```

### 2.2 Order Service - Lógica de Negocio

```java
// OrderService.java
@Service
@Slf4j
public class OrderService {
    
    private final OrderRepository orderRepository;
    private final InventoryClient inventoryClient;
    private final EventPublisher eventPublisher;
    private final IdempotencyService idempotencyService;
    
    @Transactional
    public Mono<Order> createOrder(OrderRequest request, String userId) {
        String idempotencyKey = request.getIdempotencyKey();
        
        // ✅ Idempotencia - evitar órdenes duplicadas
        return idempotencyService.checkIdempotency(idempotencyKey)
            .flatMap(exists -> {
                if (exists) {
                    return orderRepository.findByIdempotencyKey(idempotencyKey);
                }
                return processNewOrder(request, userId, idempotencyKey);
            });
    }
    
    private Mono<Order> processNewOrder(OrderRequest request, String userId, String idempotencyKey) {
        return Mono.fromCallable(() -> {
                // 1. Crear orden en estado PENDING
                Order order = Order.builder()
                    .userId(userId)
                    .items(request.getItems())
                    .total(calculateTotal(request.getItems()))
                    .status(OrderStatus.PENDING)
                    .idempotencyKey(idempotencyKey)
                    .createdAt(Instant.now())
                    .build();
                return orderRepository.save(order);
            })
            .flatMap(order -> reserveInventory(order)
                .map(reserved -> {
                    order.setInventoryReserved(reserved);
                    return order;
                })
            )
            .flatMap(order -> {
                // ✅ Publicar evento ANTES de confirmación
                // Si algo falla después, el evento permite compensación
                publishOrderCreatedEvent(order);
                return Mono.just(order);
            })
            .doOnSuccess(order -> log.info("Order created successfully: {}", order.getId()))
            .doOnError(error -> log.error("Failed to create order", error));
    }
    
    // ✅ Reserva de inventario con resiliencia
    private Mono<Boolean> reserveInventory(Order order) {
        return inventoryClient.reserveItems(order.getItems())
            .timeout(Duration.ofSeconds(3))
            .retry(2) // ✅ Retry automático
            .onErrorResume(TimeoutException.class, e -> {
                log.warn("Inventory reservation timeout, continuing with manual review flag");
                return Mono.just(false); // ✅ Degradación elegante
            })
            .onErrorResume(e -> {
                log.error("Inventory reservation failed", e);
                return Mono.error(new InventoryReservationException(
                    "Could not reserve inventory", e
                ));
            });
    }
    
    // ✅ Publicación de eventos asíncrona
    private void publishOrderCreatedEvent(Order order) {
        OrderCreatedEvent event = OrderCreatedEvent.builder()
            .eventId(UUID.randomUUID().toString())
            .orderId(order.getId())
            .userId(order.getUserId())
            .items(order.getItems())
            .total(order.getTotal())
            .inventoryReserved(order.isInventoryReserved())
            .timestamp(Instant.now())
            .build();
        
        eventPublisher.publish("order.created", event);
    }
    
    private BigDecimal calculateTotal(List<OrderItem> items) {
        return items.stream()
            .map(item -> item.getPrice().multiply(BigDecimal.valueOf(item.getQuantity())))
            .reduce(BigDecimal.ZERO, BigDecimal::add);
    }
}
```

### 2.3 Inventory Client con Resiliencia

```java
// InventoryClient.java
@Component
@Slf4j
public class InventoryClient {
    
    private final WebClient webClient;
    private final CircuitBreakerRegistry circuitBreakerRegistry;
    
    public InventoryClient(WebClient.Builder webClientBuilder,
                          CircuitBreakerRegistry circuitBreakerRegistry) {
        this.webClient = webClientBuilder
            .baseUrl("http://inventory-service")
            .build();
        this.circuitBreakerRegistry = circuitBreakerRegistry;
    }
    
    public Mono<Boolean> reserveItems(List<OrderItem> items) {
        CircuitBreaker circuitBreaker = circuitBreakerRegistry
            .circuitBreaker("inventoryService");
        
        return Mono.fromCallable(() -> 
                circuitBreaker.executeSupplier(() -> 
                    performReservation(items).block()
                )
            )
            .subscribeOn(Schedulers.boundedElastic());
    }
    
    private Mono<Boolean> performReservation(List<OrderItem> items) {
        ReservationRequest request = new ReservationRequest(items);
        
        return webClient.post()
            .uri("/api/inventory/reserve")
            .bodyValue(request)
            .retrieve()
            .onStatus(HttpStatus::is4xxClientError, response -> {
                return response.bodyToMono(String.class)
                    .flatMap(body -> {
                        log.error("Client error reserving inventory: {}", body);
                        return Mono.error(new InsufficientStockException(body));
                    });
            })
            .onStatus(HttpStatus::is5xxServerError, response -> {
                log.error("Server error from inventory service");
                return Mono.error(new InventoryServiceException(
                    "Inventory service error"
                ));
            })
            .bodyToMono(ReservationResponse.class)
            .map(ReservationResponse::isSuccess)
            .doOnSuccess(success -> 
                log.info("Inventory reservation result: {}", success)
            );
    }
}
```

### 2.4 Event Publisher

```java
// EventPublisher.java
@Component
@Slf4j
public class EventPublisher {
    
    private final RabbitTemplate rabbitTemplate;
    private final ObjectMapper objectMapper;
    
    public EventPublisher(RabbitTemplate rabbitTemplate, ObjectMapper objectMapper) {
        this.rabbitTemplate = rabbitTemplate;
        this.objectMapper = objectMapper;
    }
    
    public void publish(String eventType, Object event) {
        try {
            String message = objectMapper.writeValueAsString(event);
            
            rabbitTemplate.convertAndSend(
                "order-events-exchange",
                eventType,
                message,
                messagePostProcessor -> {
                    messagePostProcessor.getMessageProperties()
                        .setHeader("event-type", eventType);
                    messagePostProcessor.getMessageProperties()
                        .setHeader("timestamp", System.currentTimeMillis());
                    return messagePostProcessor;
                }
            );
            
            log.info("Published event: {} for order", eventType);
            
        } catch (JsonProcessingException e) {
            log.error("Failed to serialize event", e);
            // ✅ No fallar la operación principal por problemas de eventos
            // En producción: encolar para retry o alertar
        }
    }
}
```

### 2.5 Payment Service Consumer

```java
// PaymentEventConsumer.java
@Component
@Slf4j
public class PaymentEventConsumer {
    
    private final PaymentService paymentService;
    private final EventPublisher eventPublisher;
    
    @RabbitListener(queues = "payment-queue")
    public void handleOrderCreated(
        @Payload String message,
        @Header("event-type") String eventType
    ) {
        try {
            OrderCreatedEvent event = objectMapper.readValue(
                message, 
                OrderCreatedEvent.class
            );
            
            log.info("Processing payment for order: {}", event.getOrderId());
            
            // ✅ Procesamiento asíncrono con retry automático
            PaymentResult result = paymentService.processPayment(
                event.getOrderId(),
                event.getTotal()
            );
            
            if (result.isSuccess()) {
                publishPaymentSuccessEvent(event.getOrderId(), result);
            } else {
                publishPaymentFailedEvent(event.getOrderId(), result);
            }
            
        } catch (Exception e) {
            log.error("Error processing payment event", e);
            // ✅ RabbitMQ reintentará automáticamente
            throw new AmqpRejectAndDontRequeueException("Payment processing failed", e);
        }
    }
    
    private void publishPaymentSuccessEvent(String orderId, PaymentResult result) {
        PaymentSuccessEvent event = PaymentSuccessEvent.builder()
            .orderId(orderId)
            .paymentId(result.getPaymentId())
            .timestamp(Instant.now())
            .build();
        
        eventPublisher.publish("payment.success", event);
    }
    
    private void publishPaymentFailedEvent(String orderId, PaymentResult result) {
        PaymentFailedEvent event = PaymentFailedEvent.builder()
            .orderId(orderId)
            .reason(result.getFailureReason())
            .timestamp(Instant.now())
            .build();
        
        eventPublisher.publish("payment.failed", event);
    }
}
```

---

## 3. CONFIGURACIÓN DE RESILIENCIA

### 3.1 Resilience4j Configuration

```yaml
# application.yml
resilience4j:
  # Circuit Breaker
  circuitbreaker:
    configs:
      default:
        slidingWindowType: COUNT_BASED
        slidingWindowSize: 10
        minimumNumberOfCalls: 5
        failureRateThreshold: 50
        waitDurationInOpenState: 30s
        permittedNumberOfCallsInHalfOpenState: 3
        automaticTransitionFromOpenToHalfOpenEnabled: true
        
    instances:
      createOrder:
        baseConfig: default
        failureRateThreshold: 60
        slowCallRateThreshold: 80
        slowCallDurationThreshold: 2s
        
      inventoryService:
        baseConfig: default
        failureRateThreshold: 40
        waitDurationInOpenState: 60s
        
  # Rate Limiter
  ratelimiter:
    configs:
      default:
        limitForPeriod: 100
        limitRefreshPeriod: 1s
        timeoutDuration: 0s
        
    instances:
      createOrder:
        limitForPeriod: 1000
        limitRefreshPeriod: 1s
        
  # Retry
  retry:
    configs:
      default:
        maxAttempts: 3
        waitDuration: 1s
        retryExceptions:
          - org.springframework.web.client.HttpServerErrorException
          - java.util.concurrent.TimeoutException
        ignoreExceptions:
          - com.mercadorapido.exception.InsufficientStockException
          
    instances:
      inventoryService:
        maxAttempts: 3
        waitDuration: 500ms
        exponentialBackoffMultiplier: 2
        
  # Bulkhead
  bulkhead:
    configs:
      default:
        maxConcurrentCalls: 25
        
    instances:
      createOrder:
        maxConcurrentCalls: 50
        maxWaitDuration: 0ms
        
  # Thread Pool Bulkhead
  thread-pool-bulkhead:
    configs:
      default:
        coreThreadPoolSize: 10
        maxThreadPoolSize: 20
        queueCapacity: 100
        keepAliveDuration: 20ms
        
    instances:
      createOrder:
        coreThreadPoolSize: 20
        maxThreadPoolSize: 50
        queueCapacity: 200
```

### 3.2 RabbitMQ Configuration

```java
// RabbitMQConfig.java
@Configuration
public class RabbitMQConfig {
    
    @Bean
    public DirectExchange orderEventsExchange() {
        return new DirectExchange("order-events-exchange", true, false);
    }
    
    @Bean
    public Queue paymentQueue() {
        return QueueBuilder.durable("payment-queue")
            .withArgument("x-dead-letter-exchange", "dlx-exchange")
            .withArgument("x-dead-letter-routing-key", "payment-dlq")
            .withArgument("x-message-ttl", 300000) // 5 minutos
            .build();
    }
    
    @Bean
    public Queue notificationQueue() {
        return QueueBuilder.durable("notification-queue")
            .withArgument("x-dead-letter-exchange", "dlx-exchange")
            .withArgument("x-dead-letter-routing-key", "notification-dlq")
            .build();
    }
    
    @Bean
    public Queue inventoryQueue() {
        return QueueBuilder.durable("inventory-queue")
            .withArgument("x-dead-letter-exchange", "dlx-exchange")
            .withArgument("x-dead-letter-routing-key", "inventory-dlq")
            .build();
    }
    
    // Dead Letter Exchange para mensajes fallidos
    @Bean
    public DirectExchange deadLetterExchange() {
        return new DirectExchange("dlx-exchange", true, false);
    }
    
    @Bean
    public Queue paymentDLQ() {
        return QueueBuilder.durable("payment-dlq").build();
    }
    
    // Bindings
    @Bean
    public Binding paymentBinding() {
        return BindingBuilder
            .bind(paymentQueue())
            .to(orderEventsExchange())
            .with("order.created");
    }
    
    @Bean
    public Binding notificationBinding() {
        return BindingBuilder
            .bind(notificationQueue())
            .to(orderEventsExchange())
            .with("order.created");
    }
    
    @Bean
    public Binding inventoryBinding() {
        return BindingBuilder
            .bind(inventoryQueue())
            .to(orderEventsExchange())
            .with("payment.success");
    }
    
    // Configuración de retry
    @Bean
    public RabbitTemplate rabbitTemplate(ConnectionFactory connectionFactory) {
        RabbitTemplate template = new RabbitTemplate(connectionFactory);
        
        // Retry policy
        template.setRetryTemplate(retryTemplate());
        
        // Confirmaciones de publicación
        template.setConfirmCallback((correlationData, ack, cause) -> {
            if (!ack) {
                log.error("Message not confirmed: {}", cause);
            }
        });
        
        return template;
    }
    
    private RetryTemplate retryTemplate() {
        RetryTemplate retryTemplate = new RetryTemplate();
        
        ExponentialBackOffPolicy backOffPolicy = new ExponentialBackOffPolicy();
        backOffPolicy.setInitialInterval(500);
        backOffPolicy.setMultiplier(2.0);
        backOffPolicy.setMaxInterval(10000);
        
        SimpleRetryPolicy retryPolicy = new SimpleRetryPolicy();
        retryPolicy.setMaxAttempts(3);
        
        retryTemplate.setBackOffPolicy(backOffPolicy);
        retryTemplate.setRetryPolicy(retryPolicy);
        
        return retryTemplate;
    }
}
```

---

## 4. KUBERNETES DEPLOYMENT

### 4.1 Order Service Deployment

```yaml
# order-service-deployment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: order-service
  labels:
    app: order-service
    version: v1
spec:
  replicas: 3
  strategy:
    type: RollingUpdate
    rollingUpdate:
      maxSurge: 1
      maxUnavailable: 0
  selector:
    matchLabels:
      app: order-service
  template:
    metadata:
      labels:
        app: order-service
        version: v1
    spec:
      containers:
      - name: order-service
        image: mercadorapido/order-service:1.0.0
        ports:
        - containerPort: 8080
          name: http
        - containerPort: 8081
          name: actuator
        env:
        - name: SPRING_PROFILES_ACTIVE
          value: "production"
        - name: DATABASE_URL
          valueFrom:
            secretKeyRef:
              name: order-db-secret
              key: url
        - name: RABBITMQ_HOST
          value: "rabbitmq-service"
        - name: INVENTORY_SERVICE_URL
          value: "http://inventory-service:8080"
        resources:
          requests:
            memory: "512Mi"
            cpu: "500m"
          limits:
            memory: "1Gi"
            cpu: "1000m"
        livenessProbe:
          httpGet:
            path: /actuator/health/liveness
            port: 8081
          initialDelaySeconds: 30
          periodSeconds: 10
          timeoutSeconds: 5
          failureThreshold: 3
        readinessProbe:
          httpGet:
            path: /actuator/health/readiness
            port: 8081
          initialDelaySeconds: 20
          periodSeconds: 5
          timeoutSeconds: 3
          failureThreshold: 3
---
apiVersion: v1
kind: Service
metadata:
  name: order-service
spec:
  selector:
    app: order-service
  ports:
  - port: 8080
    targetPort: 8080
    name: http
  type: ClusterIP
---
apiVersion: autoscaling/v2
kind: HorizontalPodAutoscaler
metadata:
  name: order-service-hpa
spec:
  scaleTargetRef:
    apiVersion: apps/v1
    kind: Deployment
    name: order-service
  minReplicas: 3
  maxReplicas: 20
  metrics:
  - type: Resource
    resource:
      name: cpu
      target:
        type: Utilization
        averageUtilization: 70
  - type: Resource
    resource:
      name: memory
      target:
        type: Utilization
        averageUtilization: 80
  - type: Pods
    pods:
      metric:
        name: http_requests_per_second
      target:
        type: AverageValue
        averageValue: "1000"
  behavior:
    scaleDown:
      stabilizationWindowSeconds: 300
      policies:
      - type: Percent
        value: 50
        periodSeconds: 60
    scaleUp:
      stabilizationWindowSeconds: 0
      policies:
      - type: Percent
        value: 100
        periodSeconds: 30
      - type: Pods
        value: 4
        periodSeconds: 30
      selectPolicy: Max
```

### 4.2 Catalog Service Deployment (High Traffic)

```yaml
# catalog-service-deployment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: catalog-service
  labels:
    app: catalog-service
spec:
  replicas: 5  # Más réplicas base por alto tráfico
  template:
    metadata:
      labels:
        app: catalog-service
    spec:
      containers:
      - name: catalog-service
        image: mercadorapido/catalog-service:1.0.0
        ports:
        - containerPort: 8080
        env:
        - name: REDIS_HOST
          value: "redis-service"
        - name: READ_REPLICA_URL
          valueFrom:
            secretKeyRef:
              name: catalog-db-secret
              key: read-replica-url
        resources:
          requests:
            memory: "256Mi"
            cpu: "250m"
          limits:
            memory: "512Mi"
            cpu: "500m"
---
apiVersion: autoscaling/v2
kind: HorizontalPodAutoscaler
metadata:
  name: catalog-service-hpa
spec:
  scaleTargetRef:
    apiVersion: apps/v1
    kind: Deployment
    name: catalog-service
  minReplicas: 5
  maxReplicas: 50  # Puede escalar agresivamente
  metrics:
  - type: Resource
    resource:
      name: cpu
      target:
        type: Utilization
        averageUtilization: 60  # Más sensible
  behavior:
    scaleUp:
      stabilizationWindowSeconds: 0
      policies:
      - type: Percent
        value: 200  # Escala rápido
        periodSeconds: 15
```

---

## 5. MONITOREO Y OBSERVABILIDAD

### 5.1 Prometheus Metrics

```java
// MetricsConfig.java
@Configuration
public class MetricsConfig {
    
    @Bean
    public MeterRegistryCustomizer<MeterRegistry> metricsCommonTags() {
        return registry -> registry.config()
            .commonTags(
                "application", "order-service",
                "environment", System.getenv("ENVIRONMENT")
            );
    }
    
    @Bean
    public TimedAspect timedAspect(MeterRegistry registry) {
        return new TimedAspect(registry);
    }
}

// Custom Metrics
@Component
public class OrderMetrics {
    
    private final Counter ordersCreated;
    private final Counter ordersFailed;
    private final Timer orderProcessingTime;
    private final Gauge activeOrders;
    
    public OrderMetrics(MeterRegistry registry) {
        this.ordersCreated = Counter.builder("orders.created")
            .description("Total orders created")
            .tags("status", "success")
            .register(registry);
            
        this.ordersFailed = Counter.builder("orders.failed")
            .description("Total orders failed")
            .register(registry);
            
        this.orderProcessingTime = Timer.builder("orders.processing.time")
            .description("Order processing duration")
            .publishPercentiles(0.5, 0.95, 0.99)
            .register(registry);
            
        this.activeOrders = Gauge.builder("orders.active", this, OrderMetrics::getActiveOrdersCount)
            .description("Current active orders")
            .register(registry);
    }
    
    public void recordOrderCreated(String category) {
        ordersCreated.increment();
    }
    
    public void recordOrderFailed(String reason) {
        ordersFailed.increment();
    }
    
    public void recordProcessingTime(Duration duration) {
        orderProcessingTime.record(duration);
    }
    
    private double getActiveOrdersCount() {
        // Implementación para obtener órdenes activas
        return 0;
    }
}
```

### 5.2 Grafana Dashboard Query Examples

```promql
# Tasa de órdenes por segundo
rate(orders_created_total[1m])

# Latencia P95
histogram_quantile(0.95, 
  rate(orders_processing_time_bucket[5m])
)

# Tasa de errores
rate(orders_failed_total[1m]) / 
rate(orders_created_total[1m])

# Estado del Circuit Breaker
resilience4j_circuitbreaker_state{
  name="inventoryService"
}

# Throughput por servicio
sum(rate(http_server_requests_seconds_count[1m])) 
by (service)
```

---

## 6. TESTING

### 6.1 Integration Test

```java
@SpringBootTest(webEnvironment = WebEnvironment.RANDOM_PORT)
@TestPropertySource(locations = "classpath:application-test.yml")
class OrderServiceIntegrationTest {
    
    @Autowired
    private WebTestClient webTestClient;
    
    @MockBean
    private InventoryClient inventoryClient;
    
    @Autowired
    private OrderRepository orderRepository;
    
    @Test
    void shouldCreateOrderSuccessfully() {
        // Given
        OrderRequest request = createValidOrderRequest();
        when(inventoryClient.reserveItems(any()))
            .thenReturn(Mono.just(true));
        
        // When
        webTestClient.post()
            .uri("/api/orders")
            .header("X-User-Id", "user-123")
            .bodyValue(request)
            .exchange()
            
            // Then
            .expectStatus().isOk()
            .expectBody(OrderResponse.class)
            .value(response -> {
                assertThat(response.getStatus()).isEqualTo("PENDING");
                assertThat(response.getTotal()).isEqualTo(request.getTotal());
            });
        
        // Verify
        Order savedOrder = orderRepository.findAll().get(0);
        assertThat(savedOrder.getUserId()).isEqualTo("user-123");
    }
    
    @Test
    void shouldHandleInventoryServiceTimeout() {
        // Given
        OrderRequest request = createValidOrderRequest();
        when(inventoryClient.reserveItems(any()))
            .thenReturn(Mono.never()); // Simula timeout
        
        // When & Then
        webTestClient.post()
            .uri("/api/orders")
            .header("X-User-Id", "user-123")
            .bodyValue(request)
            .exchange()
            .expectStatus().is5xxServerError();
    }
}
```

### 6.2 Chaos Engineering con Chaos Monkey

```yaml
# application-chaos.yml
chaos:
  monkey:
    enabled: true
    watcher:
      component: true
      controller: true
      repository: false
      restController: true
      service: true
    assaults:
      level: 5
      latencyActive: true
      latencyRangeStart: 1000
      latencyRangeEnd: 5000
      exceptionsActive: true
      exception:
        type: java.lang.RuntimeException
      killApplicationActive: false
```

---

## CONCLUSIÓN

Este código demuestra la transformación práctica de un monolito frágil a microservicios resilientes siguiendo el Manifiesto Reactivo:

**✅ Responsive**: Timeouts, rate limiting, respuestas rápidas
**✅ Resilient**: Circuit breakers, retries, fallbacks, degradación elegante
**✅ Elastic**: Auto-scaling, bulkheads, recursos optimizados
**✅ Message-Driven**: Event bus, procesamiento asíncrono, desacoplamiento

El resultado es un sistema que no solo soporta alta carga, sino que se degrada elegantemente ante fallos.
